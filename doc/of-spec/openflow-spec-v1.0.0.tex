\documentclass[10pt]{article} 
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{color}
\usepackage{alltt}
\usepackage{rotating}
\usepackage{xtab}
\usepackage{calc}

\hbadness=10000 % No "underfull hbox" messages

\begin{document}

%\lstset{language=C}

% Define the OpenFlow version here
\newcommand{\ofversion}{1.1.0}

% Calculations of widths for multipage tables
%
% Action table
\newlength{\atactionwidth}
\newlength{\atassocwidth}
\newlength{\atdescwidth}
\setlength{\atactionwidth}{0.25\textwidth - 2 \tabcolsep}
\setlength{\atassocwidth}{0.30\textwidth - 2 \tabcolsep}
\setlength{\atdescwidth}{0.45\textwidth - 2 \tabcolsep}

\pagestyle{fancy}
\fancyhead{}
\lhead{OpenFlow Switch Specification}
%\chead{DO NOT BUILD A SWITCH FROM THIS SPECIFICATION!}
\rhead{Version \ofversion}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\fontfamily{cmr} % what about cmss?
\selectfont

\newcommand{\qosupd}[1]{{#1}}
%\newcommand{\qosupd}[1]{{\color{blue} #1}}

\title{OpenFlow Switch Specification}
\author{Version \ofversion{} ( Wire Protocol \input{define/OFP_VERSION})}
\date{\today}
\maketitle

\tableofcontents
\listoftables
\listoffigures
\clearpage

\section{Introduction}
This document describes the requirements of an OpenFlow Switch.  We recommend that you read the latest version of the OpenFlow whitepaper before reading this specification. The whitepaper is available on the  OpenFlow Consortium website (\url{http://openflow.org}). This specification covers the components and the basic functions of the switch, and the OpenFlow protocol to manage an OpenFlow switch from a remote controller.
\\\\

\begin{figure}[htbp]
\centering
\includegraphics[height=2.5in]{figure_flow_tables_secchan.png}
\caption{An OpenFlow switch communicates with a controller over a secure connection using the OpenFlow protocol.}
\label{fig:flow table and controller}
\end{figure}

\section{Switch Components}
An OpenFlow Switch consists of one or more \emph{flow tables} and a \emph{group table}, which perform packet lookups and forwarding, as well as a \emph{secure channel} to an external controller (Figure \ref{fig:flow table and controller}).  The controller manages the switch through the OpenFlow protocol.   Over this protocol, the controller can add, update, and delete flow entries, both reactively (in response to packets generated by hosts) as well as proactively (flow tables populated in advance).
\\\\
Each flow table in the switch contains a set of flow entries; each flow entry consists of fields to match packets against, activity counters, and a set of instructions to apply to matching packets.  The group table contains group entries; each group entry includes a list of action buckets with specific semantics dependent on group type.
\\\\
Flow entries match packets in priority order. If a matching entry is found, the instructions associated with the specific flow entry are executed. If no match is found in a flow table, the outcome depends on switch configuration: the packet may be forwarded to the controller over the secure channel, dropped, or may continue to the next table in the pipeline.
\\\\
Matching starts at the first table and may continue to additional tables. Flow entries may include instructions to describe packet forwarding, packet modifications, and pipeline processing.  Instructions that modify pipeline processing include specifying the next table in the pipeline and changing the metatadata field to be used in the next table lookup. Table pipeline processing stops when a packet matches a flow table entry and the instruction set does not contain a Goto-Table instruction.
\\\\
Flow entries may forward to a port. Usually, this is a physical port, but it could also be a virtual port reserved by a switch or by this specification. Virtual ports may specify generic forwarding actions such as sending to the controller, flooding or forwarding using non-OpenFlow methods, such as ``normal'' switch processing or tunnel interfaces (see \ref{ft:actions}).  The zero port is reserved and cannot be used for forwarding.
\\\\
Groups represent sets of ports for flooding, as well as more complex forwarding semantics (e.g. multipath, fast reroute and link aggregation).  As a general layer of indirection, groups also enable multiple flows to forward to a single identifier (e.g. IP forwarding to a common next hop).  This abstraction allows common output actions across flows to be changed efficiently.
\\\\
Additional port/group configuration may be handled by an external configuration protocol, which is beyond the scope of this document.

\section{Glossary}
This section describes key OpenFlow specification terms:
\begin{itemize}
\item \textbf{Byte}: an 8-bit octet.
\item \textbf{Port}: is a physical or virtual port. Virtual ports include reserved ports defined by this specification as well as higher level abstractions that may be defined in the switch using non-OpenFlow methods (e.g. link aggregation groups, tunnels, loopback interfaces).
\item \textbf{Match Field}: a field against which a packet is matched, including packet headers, the ingress port, and the metadata value.
\item \textbf{Metadata}: a maskable register value that is used to carry information from one table to the next.
\item \textbf{Instruction}: an operation executed when a packet matches a flow entry. An instruction either contains a set of actions or modifies pipeline processing.
\item \textbf{Action}: an operation that forwards the packet to a port or modifies the packet, such as decrementing the TTL field. Actions may be specified as part of the instruction set associated with a flow entry or in an action bucket associated with a group entry.
\item \textbf{Action Set}: a set of actions that are carried between tables along with the match fields and are executed when the instruction set instructs the packet to exit the processing pipeline
\item \textbf{Group}: a list of action buckets and some means of choosing one or more of those buckets to apply on a per-packet basis.
\item \textbf{Action Bucket}: a set of actions and associated parameters, defined for groups.
\item \textbf{Tag}: a header that can be inserted or removed from a packet via push and pop actions.
\item \textbf{Outermost Tag}: the tag that appears closest to the beginning of a packet.
\end{itemize}

\section{OpenFlow Tables}
This section describes the components of flow table and group table entries, along with the mechanics of matching and action handling.

\subsection{Flow Table Entry}
\label{ft:flowtableentry}

\begin{table}[hbp]
\centering
\begin{tabular}{|c|c|c|}
\hline	
Match Fields & Counters & Instructions\\ 
\hline	
\end{tabular}
\caption{A flow entry consists of match fields, counters, and instructions.}
\label{table:flow entry}
\end{table}

Each flow table entry (see Table \ref{table:flow entry}) contains: 
\begin{itemize} 
\item \textbf{match fields}: to match against packets. These consist of the ingress port and packet headers, and optionally metadata specified by a previous table.
\item \textbf{counters}: to update for matching packets
\item \textbf{instructions} to modify the action set or pipeline processing
\end{itemize} 

\subsection{Group Table}
A group table consists of group entries.  The ability for a flow to point to a \emph{group} enables OpenFlow to represent additional methods of forwarding (e.g. multipath and flood).
\\\\
\begin{table}[hbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
Group Identifier & Group Type & Action Buckets\\
\hline
\end{tabular}
\caption{A group entry consists of a group identifier, a group type and a list of action buckets.}
\label{table:group entry}
\end{table}
Each group entry (see Table \ref{table:group entry}) contains:
\begin{itemize}
\item \textbf{group identifier}: a 32 bit unsigned integer uniquely identifying the group
\item \textbf{group type}: to determine group semantics (see Section~\ref{sec:group types})
\item \textbf{action buckets}: an ordered list of action buckets, where each action bucket contains a set of actions to execute
\end{itemize}

\subsubsection{Group Types}
\label{sec:group types}
The following group types are defined:

\begin{itemize}
\item \textbf{flood}: Execute all buckets in the group.  Packets directed out the ingress port are dropped by default.  If the controller writer wants to forward out the ingress port, the bucket(s) should include a forward action to the \verb|OFPP_IN_PORT| in each bucket where this is desired.  This group is used for multicast or broadcast forwarding.
\item \textbf{multipath}: Execute one bucket in the group.  Packets are sent to a single bucket in the group, based on a switch-computed selection algorithm (e.g. hash on some user-configured tuple or simple round robin).  All configuration and state for the selection algorithm is external to OpenFlow.  When a port specified in a bucket in a multipath group goes down, the switch may restrict bucket selection to the remaining set (those with forwarding actions to live ports). This behavior may reduce the disruption of a downed link or switch.
\item \textbf{indirect}: Execute the one defined bucket in this group.  Allows multiple flows or groups to point to a common group identifier, supporting faster, more efficient convergence (e.g. next hops for IP forwarding).  This group type is effectively identical to flood groups with one bucket.
\item \textbf{fast failover}: Execute the first live bucket.  Each action bucket is associated with a specific port and/or group that controls its liveness.  Enables the switch to change forwarding without requiring a round trip to the controller.  If no buckets are live, packets are dropped. This group type must implement a \textit{liveness mechanism}(see \ref{group_table:sec_chan:group_mod}).
\end{itemize}

\subsection{Match Fields}
\begin{table}[hbp]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{ |X|X|X|X|X|X|X|X|X|X|X|X|X|X|X| }
\hline
\begin{sideways}Ingress Port \end{sideways} &
\begin{sideways}Metadata \end{sideways} &
\begin{sideways}Ether src \end{sideways} &
\begin{sideways}Ether dst \end{sideways} &
\begin{sideways}Ether type \end{sideways} &
\begin{sideways}VLAN id \end{sideways} &
\begin{sideways}VLAN priority \end{sideways} &
\begin{sideways}MPLS label \end{sideways} &
\begin{sideways}MPLS traffic class \end{sideways} &
\begin{sideways}IP src \end{sideways} &
\begin{sideways}IP dst \end{sideways} &
\begin{sideways}IP proto \end{sideways} &
\begin{sideways}IP ToS bits \end{sideways} &
\begin{sideways}TCP/ UDP src port \end{sideways} &
\begin{sideways}TCP/ UDP dst port \end{sideways}
\\ 
\hline
\end{tabularx}
\caption{Fields from packets used to match against flow entries.}
\label{table:match fields}
\end{table}

Table \ref{table:match fields} shows the match fields an incoming packet is compared against. Each entry contains a specific value, or ANY, which matches any value. If the switch supports subnet masks or arbitrary bitmasks on the Ethernet source and/or destinations fields, or on the IP source and/or destination fields, these can more precisely specify matches.  The fields in the OpenFlow tuple are listed in Table \ref{table:match fields} and details on the properties of each field are described in Table \ref{table:header field details}. In addition to packet headers, matches can also be performed against the ingress port and metadata fields. Metadata may be used to pass information between tables in a switch.
\\\\
\begin{table}[hbp]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{ |X|X|X|X| }
\hline Field & Bits & When applicable & Notes \\
\hline Ingress Port & 32 & All packets & Numerical representation of incoming port, starting at 1. This may be a physical or virtual port as defined by the switch implementation. \\
\hline Metadata & 64 & Table 1 and above & \\
\hline Ethernet source address & 48 & All packets on enabled ports & Can use arbitrary bitmask \\
\hline Ethernet destination address & 48 & All packets on enabled ports & Can use arbitrary bitmask \\
\hline Ethernet type & 16 & All packets on enabled ports & An OpenFlow switch is required to match the type in both standard Ethernet and 802.2 with a SNAP header and OUI of 0x000000.  The special value of 0x05FF is used to match all 802.3 packets without SNAP headers. \\
\hline VLAN id & 12 & All packets with VLAN tags & VLAN identifier of \emph{outermost} VLAN tag. \\
\hline VLAN priority & 3 & All packets with VLAN tags & VLAN PCP field of \emph{outermost} VLAN tag. \\
\hline MPLS label & 20 & All packets with MPLS tags & Match on \emph{outermost} MPLS tag. \\
\hline MPLS traffic class & 3 & All packets with MPLS tags & Match on \emph{outermost} MPLS tag. \\
\hline IP source address & 32 & All IP and ARP packets & Can use subnet mask or arbitrary bitmask \\
\hline IP destination address & 32 & All IP and ARP packets & Can use subnet mask or arbitrary bitmask \\
\hline IP protocol & 8 & All IP and IP over Ethernet, ARP packets & Only the lower 8 bits of the ARP opcode are used \\
\hline IP ToS bits & 6 & All IP packets & Specify as 8-bit value and place ToS in upper 6 bits. \\
\hline Transport source port / ICMP Type & 16 & All TCP, UDP, and ICMP packets & Only lower 8 bits used for ICMP Type \\
\hline Transport destination port / ICMP Code & 16 & All TCP, UDP, and ICMP packets & Only lower 8 bits used for ICMP Code \\
\hline
\end{tabularx}
\caption{Field lengths and the way they must be applied to flow entries.}
\label{table:header field details}
\end{table}Switch designers are free to implement the internals in any way convenient provided that correct functionality is preserved. For example, while a flow may use a flood group to forward to multiple ports, a switch designer may choose to implement this as a single bitmask within the hardware forwarding table.

\subsection{Counters}

Counters may be maintained for each table, flow, port, queue, group, and bucket.  OpenFlow-compliant counters may be implemented in software and maintained by polling hardware counters with more limited ranges.
\\\\
Table \ref{table:counters} contains the set of counters.  Duration refers to the time the flow has been installed in the switch.  The Receive Errors field includes all explicitly specified errors, including frame, overrun, and CRC errors, plus any others.  Counters wrap around with no overflow indicator.  
\begin{table}[!hbp]
\centering
\footnotesize
%\begin{tabularx}{\textwidth}{ |X|X| }
\begin{tabular}{ |l|c| }
\hline Counter & Bits	 \\
\hline \multicolumn{2}{|c|}{Per Table} \\
\hline Active Entries & 32 \\
\hline Packet Lookups & 64 \\
\hline Packet Matches & 64 \\
\hline \multicolumn{2}{|c|}{Per Flow} \\
\hline Received Packets & 64 \\
\hline Received Bytes & 64 \\
\hline Duration (seconds) & 32 \\
\hline Duration (nanoseconds) & 32 \\
\hline  \multicolumn{2}{|c|}{Per Port} \\
\hline Received Packets & 64 \\
\hline Transmitted Packets & 64 \\
\hline Received Bytes & 64 \\
\hline Transmitted Bytes & 64 \\
\hline Receive Drops & 64 \\
\hline Transmit Drops & 64 \\
\hline Receive Errors & 64 \\
\hline Transmit Errors & 64 \\
\hline Receive Frame Alignment Errors & 64 \\
\hline Receive Overrun Errors & 64 \\
\hline Receive CRC Errors & 64 \\
\hline Collisions & 64 \\
\hline  \multicolumn{2}{|c|}{\qosupd{Per Queue}} \\
\hline \qosupd{Transmit Packets} & \qosupd{64} \\
\hline \qosupd{Transmit Bytes} & \qosupd{64} \\
\hline \qosupd{Transmit Overrun Errors} & \qosupd{64}\\
\hline \multicolumn{2}{|c|}{Per Group} \\
\hline Ref Count & 32 \\
\hline Packet Count & 64 \\
\hline Byte Count & 64 \\
\hline \multicolumn{2}{|c|}{Per Bucket} \\
\hline Packet Count & 64 \\
\hline Byte Count & 64 \\
\hline
\end{tabular}
\caption{List of counters}
\label{table:counters}
\end{table}

\subsection{Instructions}
\label{ft:instructions}
Each flow entry contains a set of instructions that are executed when a packet matches the entry. These instructions result in changes to the packet, action set and/or pipeline processing (see: \ref{ft:actionset}). Supported instructions include:
\begin{itemize} 
\item \textbf{Clear-Actions}: Clears all the actions in the action set immediately.
\item \textbf{Apply-Actions \textit{action(s)}}: Applies the specific action(s) immediately, without any change to the Action Set. This instruction may be used to modify the packet between two tables or to execute multiple actions of the same type.
\item \textbf{Write-Actions \textit{action(s)}}: Merges the specified action(s) into the current action set.  If an action of the given type exists in the current set, overwrite it, otherwise add it.
\item \textbf{Write-Metadata \textit{metadata / mask}}: Writes the masked metadata value into the metadata field.
\item \textbf{Goto-Table \textit{next-table-id}}: Indicates the next table in the processing pipeline. The table-id must be greater than the current table-id.
\end{itemize} 

A switch may reject a flow entry if it is unable to execute the instructions associated with the flow entry. In this case, the switch must return an unsupported flow error (see \ref{sec:flow mod messages}).  Flow tables may not support every match and every instruction.

\subsection{Action Set}
\label{ft:actionset}
An action set is associated with each packet. This set is empty by default. A flow entry can modify the action set using instructions associated with a particular match. The action set is carried between flow tables. When an instruction set does not contain a \textit{Goto-Table} instruction, the actions in the action set are executed. If the action set does not contain an output action, the packet will be dropped. The output action in the action set is executed last.
\\\\
An action set contains a maximum of one action of each type, and may not simultaneously contain both Forward and Group actions. When multiple actions of the same type are required, e.g. pushing multiple MPLS labels or popping multiple MPLS labels, the \emph{Apply-Actions} instruction may be used.
\\\\
If a packet does not match any entry in a flow table, it is forwarded to the controller. The controller may forward or drop the packet. The controller may also respond by installing appropriate flow entries to process similar packets. The controller can prevent this default behavior by installing a low priority catch-all flow entry to drop unmatched packets.

\begin{figure}[htbp]
\centering
\includegraphics[height=1.85in]{figure_packet_flow.png}
\caption{Packets are matched against multiple tables in the pipeline}
\label{fig:packet flow multiple tables}
\end{figure}

\subsection{Actions}
\label{ft:actions}
Each packet is associated with an action set \ref{ft:actionset}. The action set dictates how the switch modifies or forwards a packet.  This action set is executed when a matching flow entry does not specify a \textit{Goto-Table} instruction. If no output actions are present in the action set, the packet is dropped. Actions in the action set are processed in arbitrary order, except for the output action, which is executed last.
\\\\
A switch is not required to support all action types --- just those marked ``Required Actions'' below. When connecting to the controller, a switch indicates which of the ``Optional Actions'' it supports.
\\\\
OpenFlow-compliant switches come in two types: \emph{OpenFlow-only}, and \emph{Hybrid OpenFlow/non-OpenFlow}.
OpenFlow-only switches do not support the \textbf{Forward-to-NORMAL} action, while Hybrid OpenFlow/non-OpenFlow switches may support the \textbf{Forward-to-NORMAL} action.  Either type of switch can also support the \textbf{Forward-to-FLOOD} action.
\\\\
\textbf{Required Action:} \textit{Forward}. 
OpenFlow switches must support forwarding the packet to physical ports and the following virtual ones:
\begin{itemize}
\item \textbf{ALL:} Send the packet out all physical ports, including \verb|LOCAL| port, but not including the ingress port and ports that are configured \verb|OFPPC_NO_FWD|.
\item \textbf{CONTROLLER:} Encapsulate and send the packet to the controller.
\item \textbf{LOCAL:} Send the packet to the switch's local networking stack.
\item \textbf{TABLE:} Perform actions in flow table.  Only for packet-out messages.
\item \textbf{IN\_PORT:} Send the packet out the ingress port. 
\end{itemize}
\textbf{Optional Action:} \textit{Forward}.
The switch may optionally support the following virtual ports:
\begin{itemize}
\item \textbf{NORMAL:} Process the packet using the traditional forwarding path supported by the switch (i.e., traditional L2, VLAN, and L3 processing.) If the switch cannot forward entries for the OpenFlow-specific VLAN back to the normal processing route, it must indicate that it does not support this action.
\\
Note: Hybrid OpenFlow/non-OpenFlow switches may provide a classification mechanism outside of OpenFlow that routes traffic to \emph{either} the OpenFlow path or the normal processing path. For example, a switch may use the VLAN tag or input port to decide whether to process the packet with OpenFlow or the normal processing path.
\item \textbf{FLOOD:} Send the packet out all physical ports and the \verb|LOCAL| port, but not to the ingress port, ports that are configured \verb|OFPPC_NO_FWD|, or ports that are in \verb|OFPPS_BLOCKED| state. The switch may optionally restrict forwarding to the VLAN matching the packet VLAN header field.

\end{itemize}
The controller will only ask the switch to send to multiple physical ports simultaneously if the switch indicates it supports this behavior in the initial handshake (see section \ref{cts:handshake}).  
\\\\
\textbf{\qosupd{Optional Action:}} \emph{\qosupd{Set-Queue}}. \qosupd{The set-queue action sets the queue id for a packet. When the packet is forwarded to a port using the output action, the queue id determine which queue attached to this port is used for forwarding the packet. Forwarding behavior is dictated by the configuration of the queue and is used to provide basic Quality-of-Service (QoS) support (see section \ref{cts:qos}).}
\\\\
\textbf{Required Action:} \emph{Drop}.  A flow entry with no specified action indicates that all matching packets should be dropped.
\\\\
\textbf{Optional Action:} \emph{Push-Tag/Pop-Tag}.  Switches may support the ability to push/pop tags as shown in Table \ref{table:push pop actions}.  To aid integration with existing networks, we suggest that the ability to push/pop VLAN tags be supported.

The ordering of header fields/tags is:
\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ethernet & VLAN & MPLS & ARP/IP & TCP/UDP (IP-only) \\
\hline
\end{tabular}
\end{center}
Newly pushed tags should \emph{always} be inserted as the outermost tag in this ordering. When a new VLAN tag is pushed, it should be the outermost VLAN tag inserted immediately after the Ethernet header. Likewise, when a new MPLS shim header is pushed, it should be the outermost MPLS tag, inserted after any VLAN tags.
\\\\
Note: Refer to section~\ref{sec:push field defaults} for information on default field values.
\\\\
\textbf{Optional Action:} \emph{Modify-Field}.  While not strictly required, the actions shown in Table \ref{table:field modify actions}  greatly increase the usefulness of an OpenFlow implementation.  To aid integration with existing networks, we suggest that VLAN modification actions be supported. Modify-Field actions should \emph{always} be applied to the outermost-possible header (e.g.~a ``Set VLAN ID'' action always sets the ID of the outermost VLAN tag).
\\\\
\textbf{Required Action:} \emph{Group}.  Process the packet through the specified group.  The exact interpretation depends on group type. 

\begin{table}[hbp]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{ |l|c|X| }
\hline
Action & Associated Data & Description \\
\hline
Push VLAN header &
Ethertype &
Push a new VLAN header onto the packet.

The ethertype is used as the ethertype for the tag. Only ethertype 0x8100 and 0x88a8 should be used.
\\
\hline
Pop VLAN header &
- &
Pop the outer-most VLAN header from the packet. \\
\hline
Push MPLS header &
Ethertype &
Push a new MPLS shim header onto the packet.

The ethertype is used as the ethertype for the header only if the new tag being pushed is the bottom of stack. Only ethertype 0x8847 and 0x8848 should be used.
\\
\hline
Pop MPLS header &
Ethertype &
Pop the outer-most MPLS tag or shim header from the packet.

The ethertype is only used when popping the bottom of stack and indicates the ethertype of the payload.
\\
\hline
\end{tabularx}
\caption{Push/pop tag actions.}
\label{table:push pop actions}
\end{table}

\bottomcaption{Field-modify actions.}
\label{table:field modify actions}
\tablefirsthead{\hline \textbf{Action} & \textbf{Associated Data} &
                       \textbf{Description} \\
		       \hline }
\tablehead{\multicolumn{3}{c}%
           {{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
           \hline \textbf{Action} & \textbf{Associated Data} &
                  \textbf{Description} \\
	          \hline }
\tablelasthead{\multicolumn{3}{c}%
           {{\bfseries \tablename\ \thetable{} -- concluded from previous page}} \\
           \hline \textbf{Action} & \textbf{Associated Data} &
                  \textbf{Description} \\
	          }
\tabletail{\hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline}
\tablelasttail{\hline}
\xentrystretch{0}
\begin{xtabular}{ |p{\atactionwidth}|p{\atassocwidth}|p{\atdescwidth}| }
Set Ethernet source MAC address &
48 bits: New source MAC address &
Replace the existing Ethernet source MAC address. \\
\hline
Set Ethernet destination MAC address &
48 bits: New destination MAC address &
Replace the existing Ethernet destination MAC address. \\
\hline
Set VLAN ID &
12 bits: New VLAN ID &
Replace the existing VLAN ID.
Only applies to packets with an existing VLAN tag. \\
\hline
Set VLAN priority &
3 bits: New VLAN priority &
Replace the existing VLAN priority.
Only applies to packets with an existing VLAN tag. \\
\hline
Set MPLS label &
20 bits: New MPLS label &
Replace the existing MPLS label.
Only applies to packets with an existing MPLS shim header. \\
\hline
Set MPLS traffic class &
3 bits: New MPLS traffic class &
Replace the existing MPLS traffic class.
Only applies to packets with an existing MPLS shim header. \\
\hline
Set MPLS TTL &
8 bits: New MPLS TTL &
Replace the existing MPLS TTL.
Only applies to packets with an existing MPLS shim header. \\
\hline
Decrement MPLS TTL &
- &
Decrement the MPLS TTL.
Only applies to packets with an existing MPLS shim header. \\
\hline
Set IPv4 source address &
32 bits: New IPv4 source address &
Replace the existing IP source address and update the IP checksum (and TCP/UDP checksum if applicable).
Only applies to IPv4 packets. \\
\hline
Set IPv4 destination address &
32 bits: New IPv4 destination address &
Replace the existing IP destination address and update the IP checksum (and TCP/UDP checksum if applicable).
Only applies to IPv4 packets. \\
\hline
Set IPv4 ToS bits &
6 bits: New IPv4 ToS &
Replace the existing IP ToS and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Set IPv4 TTL &
8 bits: New IPv4 TTL &
Replace the existing IP TTL and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Decrement IPv4 TTL &
- &
Decrement the IP TTL field and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Set transport source port &
16 bits: New TCP or UDP source port &
Replace the existing TCP/UDP source port and update the TCP/UDP checksum.
Only applies to TCP and UDP packets.\\
\hline
Set transport destination port &
16 bits: New TCP or UDP destination port &
Replace the existing TCP/UDP destination port and update the TCP/UDP checksum
Only applies to TCP and UDP packets.\\
\hline
Copy TTL outwards&
- &
Copy the TTL from next-to-outermost to outermost header with TTL.

Copy can be IP-to-IP, MPLS-to-MPLS, or IP-to-MPLS.
\\
\hline
Copy TTL inwards&
- &
Copy the TTL from outermost to next-to-outermost header with TTL.

Copy can be IP-to-IP, MPLS-to-MPLS, or MPLS-to-IP.
\\
\end{xtabular}

\subsubsection{Default values for fields on push}
\label{sec:push field defaults}
Field values should be copied from existing outer headers to new outer headers when executing a push action. New fields without corresponding existing fields should be set to \emph{zero}. Table~\ref{table:push field copy} details the existing fields from which a new field may take it's value.

\begin{table}[hbp]
\centering
\begin{tabular}{p{0.3\textwidth}p{0.3\textwidth}}
\textbf{New Fields} & \textbf{Existing Field(s)} \\
\hline
VLAN ID & VLAN ID \\
\hline
VLAN priority & VLAN priority \\
\hline
MPLS label & MPLS label \\
\hline
MPLS traffic class & MPLS traffic class \\
\hline
MPLS TTL & MPLS TTL \\
 & IP TTL \\
\hline
IP source address & IP source address \\
\hline
IP destination address & IP destination address \\
\hline
IP TTL & IP TTL \\
 & MPLS TTL \\
\end{tabular}
\caption{Existing fields that may be copied into new fields on a push action.}
\label{table:push field copy}
\end{table}

Fields in new headers may be overridden by specifying a ``set'' action for the appropriate field(s) after the push operation.

\subsection{Matching}
\begin{figure}[!htb]
\centering
\includegraphics[height=1.6in]{packet_flow_flowchart.png}
\caption{Packet flow in an OpenFlow switch.}
\label{fig:packet_flow}
\end{figure}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{header_parsing_flowchart}
\caption{Flowchart showing how match fields are parsed for matching.}
\label{fig:header_parsing}
\end{figure}

On receipt of a packet, an OpenFlow Switch performs the functions shown in Figure \ref{fig:packet_flow}. Match fields used for the table lookup depend on the packet type as described below (and shown in Figure \ref{fig:header_parsing}).

\begin{itemize}
\item Rules specifying an ingress port are matched against the port that received the packet.
\item The Ethernet headers as specified in Table \ref{table:match fields} are used for all packets.
\item If the first header \emph{after} the Ethernet header is a VLAN header (Ethernet type 0x8100 or 0x88a8), the \emph{outermost} VLAN ID and PCP fields are used in the lookup. The Ethernet type following the \emph{last} VLAN header is used in subsequent rules. Additional VLAN headers are skipped.
\item (Optional) If the first header \emph{after} the Ethernet or VLAN header is an MPLS shim header (Ethernet type equal to 0x8847 or 0x8848), the \emph{outermost} MPLS label and traffic class are used. Additional MPLS shim headers are skipped and lookup is performed immediately without considering any further fields.
\item (Optional) For ARP packets (Ethernet type equal to 0x0806), the lookup fields include the contained IP source and destination fields and the ARP opcode.
\item For IP packets (Ethernet type equal to 0x0800), the lookup fields also include those in the IP header.
\item For IP packets that are TCP or UDP (IP protocol is equal to 6 or 17), the lookup includes the transport ports.
\item For IP packets that are ICMP (IP prototcol is equal to 1), the lookup includes the Type and Code fields.  
\item For IP packets with nonzero fragment offset or More Fragments bit set, the transport ports are set to zero for the lookup.
\end{itemize}
A packet matches a flow table entry if the values in the match fields used for the lookup (as defined above) match those defined in the flow table.  If a flow table field has a value of ANY, it matches all possible values in the header.  
\\\\
To handle the various Ethernet framing types, matching the Ethernet type is handled in a slightly different manner.  If the packet is an Ethernet II frame, the Ethernet type is handled in the expected way.  If the packet is an 802.3 frame with a SNAP header and Organizationally Unique Identifier (OUI) of 0x000000, the SNAP protocol id is matched against the flow’s Ethernet type.  A flow entry that specifies an Ethernet type of 0x05FF, matches all Ethernet 802.2 frames without a SNAP header and those with SNAP headers that do not have an OUI of 0x000000.  
\\\\
Packets are matched against flow entries based on prioritization. Higher priority entries must match before lower priority ones.  If multiple entries have the same priority, the switch is free to choose any ordering.  Higher numbers have higher priorities.
\\\\
For each packet that matches a flow entry, the associated counters for that entry are updated.  If no matching entry can be found for a packet, the packet is sent to the controller over the secure channel.

\section{Secure Channel}
The secure channel is the interface that connects each OpenFlow switch to a controller.  Through this interface, the controller configures and manages the switch, receives events from the switch, and sends packets out the switch.
\\\\
Between the datapath and the secure channel, the interface is implementation-specific, however all secure channel messages must be formatted according to the OpenFlow protocol. 
\\\\
Support for multiple simultaneous controllers is currently undefined.

\subsection{OpenFlow Protocol Overview}
The OpenFlow protocol supports three message types, \emph{controller-to-switch}, \emph{asynchronous}, and \emph{symmetric}, each with multiple sub-types.  Controller-to-switch messages are initiated by the controller and used to directly manage or inspect the state of the switch.  Asynchronous messages are initiated by the switch and used to update the controller of network events and changes to the switch state. Symmetric messages are initiated by either the switch or the controller and sent without solicitation.  The message types used by OpenFlow are described below.

\subsubsection{Controller-to-Switch}
Controller/switch messages are initiated by the controller and may or may not require a response from the switch.
\\\\
\textbf{Features:}  The controller may request the capabilties of a switch by sending a features request; the switch must respond with a features reply that specifies the capabilities of the switch. This is commonly performed upon Transport Layer Security (TLS) session establishment.
\\\\
\textbf{Configuration:} The controller is able to set and query configuration parameters in the switch.  The switch only responds to a query from the controller.
\\\\
\textbf{Modify-State:} Modify-State messages are sent by the controller to manage state on the switches.  Their primary purpose is to add/delete and modify flows and groups in the OpenFlow tables and to set switch port properties.
\\\\
\textbf{Read-State:} Read-State messages are used by the controller to collect statistics from the switch.
\\\\\
\textbf{Send-Packet}:  These are used by the controller to send packets out of a specified port on the switch.
\\\\
\textbf{Barrier}: Barrier request/reply messages are used by the controller to ensure message dependencies have been met or to receive notifications for completed operations.  

\subsubsection{Asynchronous}
Asynchronous messages are sent without the controller soliciting them from a switch.  Switches send asynchronous messages to the controller to denote a packet arrival, switch state change, or error.  The four main asynchronous message types are described below.
\\\\
\textbf{Packet-in:} For all packets that do not have a matching flow entry, a packet-in event is sent to the controller (or if a packet matches an entry with a ``send to controller" action).  If the switch has sufficient memory to buffer packets that are sent to the controller, the packet-in events contain some fraction of the packet header (by default \input{define/OFP_DEFAULT_MISS_SEND_LEN} bytes) and a buffer ID to be used by the controller when it is ready for the switch to forward the packet.  Switches that do not support internal buffering (or have run out of internal buffering) must send the full packet to the controller as part of the event.
\\\\
\textbf{Flow-Removed:} When a flow entry is added to the switch by a flow modify message, an idle timeout value indicates when the entry should be removed due to a lack of activity, as well as a hard timeout value that indicates when the entry should be removed, regardless of activity.  The flow modify message also specifies whether the switch should send a flow removed message to the controller when the flow expires.  Flow modify messages which delete flows should generate flow removed messages for any flows with the \verb|OFPFF_SEND_FLOW_REM| flag set.
\\\\
\textbf{Port-status:} The switch is expected to send port-status messages to the controller as port configuration state changes.  These events include change in port status events (for example, if it was brought down directly by a user).
\\\\
\textbf{Error:} The switch is able to notify the controller of problems using error messages. 

\subsubsection{Symmetric}
Symmetric messages are sent without solicitation, in either direction.
\\\\
\textbf{Hello:} Hello messages are exchanged between the switch and controller upon connection startup.
\\\\
\textbf{Echo:} Echo request/reply messages can be sent from either the switch or the controller, and must return an echo reply.  They can be used to indicate the latency, bandwidth, and/or liveness of a controller-switch connection.
\\\\
\textbf{Experimenter:} Experimenter messages provide a standard way for OpenFlow switches to offer additional functionality within the OpenFlow message type space.  This is a staging area for features meant for future OpenFlow revisions.

\subsection{Connection Setup}
The switch must be able to establish communication with a controller at a user-configurable (but otherwise fixed) IP address, using a user-specified port.  Traffic to and from the secure channel is not checked against the flow table.  Therefore, the switch must identify incoming traffic as local before checking it against the flow table.  Future versions of the protocol specification will describe a dynamic controller discovery protocol in which the IP address and port for communicating with the controller is determined at runtime.
\\\\
When an OpenFlow connection is first established, each side of the connection must immediately send an \verb|OFPT_HELLO| message with the \verb|version| field set to the highest OpenFlow protocol version supported by the sender.  Upon receipt of this message, the recipient may calculate the OpenFlow protocol version to be used as the smaller of the version number that it sent and the one that it received.
\\\\
If the negotiated version is supported by the recipient, then the connection proceeds. Otherwise, the recipient must reply with an \verb|OFPT_ERROR| message with a \verb|type| field of \verb|OFPET_HELLO_FAILED|, a \verb|code| field of \verb| OFPHFC_COMPATIBLE|, and optionally an ASCII string explaining the situation in \verb|data|, and then terminate the connection.

\subsection{Connection Interruption}
In the case that a switch loses contact with the controller, as a result of a echo request timeout, TLS session timeout, or other disconnection, it should attempt to contact one or more backup controllers.  The ordering of the controller IP addresses is not specified by the protocol.
\\\\
If some number of attempts to contact a controller (zero or more) fail, the switch may either enter ``fail secure mode'' or ``fail standalone mode'', depending on the switch implementation and its configuration. In ``fail secure mode'', the switch continues to operate according to OpenFlow procedures, with the exception that packets and messages destined to the controller are dropped and no new flow table entries are set up by the controller. In ``fail standalone mode'', the switch process all packets using the \verb|OFPP_NORMAL| port; in other words, the switch acts as a legacy Ethernet switch or router. 
\\\\
Upon connecting to a controller again, the existing flow entries remain.  The controller then has the option of deleting all flow entries, if desired.
\\\\
The first time a switch starts up, it will operate in either ``fail secure mode'' or ``fail standalone mode'' mode.  Configuration of the default set of flow entries to be used at startup is outside the scope of the OpenFlow protocol.

\subsection{Encryption}
The switch and controller communicate through a TLS connection.  The TLS connection is initiated by the switch on startup to the controller, which is located by default on TCP port \input{define/OFP_TCP_PORT}.   The switch and controller mutually authenticate by exchanging certificates signed by a site-specific private key.  Each switch must be user-configurable with one certificate for authenticating the controller (controller certificate) and the other for authenticating to the controller (switch certificate).

\subsection{Flow Table Modification Messages}
\label{sec:flow mod messages}
\label{flow_table:sec_chan:flow_add}
\label{flow_table:sec_chan:flow_mod}
\label{flow_table:sec_chan:flow_removal}
Flow table modification messages can have the following types:
\input{enum/ofp_flow_mod_command}
For ADD requests with the \verb|OFPFF_CHECK_OVERLAP| flag set, the switch must first check for any overlapping flow entries.  Two flow entries overlap if a single packet may match both, and both entries have the same priority.  If an overlap conflict exists between an existing flow entry and the ADD request, the switch must refuse the addition and respond with an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMFC_OVERLAP| code.
\\\\
For valid (non-overlapping) ADD requests, or those with no overlap checking, the switch must insert the flow entry to the requested table.  If a flow entry with identical match fields and priority already resides in the requested table, then that entry, including its counters, must be removed, and the new flow entry added.
\\\\
If a switch cannot find any table in which to add the incoming flow entry, the switch should send an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMFC_ALL_TABLES_FULL| code.
\\\\
If the instructions in a flow mod message are unsupported, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMC_BAD_INSTRUCTION|.
\\\\
If the match in a flow mod specifies an arbitrary bitmask for either the datalink or network addresses which the switch cannot support, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and either \verb|OFPFMFC_BAD_DL_ADDR_MASK| or \verb|OFPFMFC_BAD_NW_ADDR_MASK|. (If the bitmasks specified in \emph{both} the datalink and network addresses are not supported then \verb|OFPFMFC_BAD_DL_ADDR_MASK| should be used.)
\\\\
If any action references a port that will never be valid on a switch, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and \verb|OFPBAC_BAD_OUT_PORT| code.  If the referenced port may be valid in the future, e.g. when a linecard is added to a chassis switch, or a port is dynamically added to a software switch, the switch may either silently drop packets sent to the referenced port, or immediately return an \verb|OFPBAC_BAD_OUT_PORT| error and refuse the flow mod.
\\\\
If the action list in a flow mod message references a group that is not currently defined on the switch, or is a reserved group, such as \verb|OFPG_ALL|, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and \verb|OFPBAC_BAD_OUT_GROUP| code.
\\\\
For MODIFY requests, if a flow entry with identical match fields does not current reside in any table, the MODIFY acts like an ADD, and the new flow entry must be inserted with zeroed counters.  Otherwise, the actions field is changed on the existing entry and its counters and idle time fields are left unchanged.
\\\\
For DELETE requests, if no flow entry matches, no error is recorded, and no flow table modification occurs.  If flow entries match, and must be deleted, then each normal entry with the \verb|OFPFF_SEND_FLOW_REM| flag set should generate a flow removed message.
\\\\
MODIFY and DELETE flow mod commands have corresponding \_STRICT versions.   Without \_STRICT appended, the wildcards are active and all flows that match the description are modified or removed.  If \_STRICT is appended, all fields, including the wildcards and priority, are strictly matched against the entry, and only an identical flow is modified or removed.  For example, if a message to remove entries is sent that has all the wildcard flags set, the DELETE command would delete all flows from all tables, while the DELETE\_STRICT command would only delete a rule that applies to all packets at the specified priority.
\\\\
For non-strict MODIFY and DELETE commands that contain wildcards, a match will occur when a flow entry exactly matches or is more specific than the description in the flow\_mod command. For example, if a DELETE command says to delete all flows with a destination port of 80, then a flow entry that is all wildcards will not be deleted. However, a DELETE command that is all wildcards will delete an entry that matches all port 80 traffic.  This same interpretation of mixed wildcard and exact match fields also applies to individual and aggregate flows stats.  
\\\\
DELETE and DELETE\_STRICT commands can be optionally filtered by destination group or output port.  If the \verb|out_port| field contains a value other than \verb|OFPP_NONE|, it introduces a constraint when matching.  This constraint is that the rule must contain an output action directed at the specified group or port.  This field is ignored by ADD, MODIFY, and MODIFY\_STRICT messages.
\\\\
MODIFY, MODIFY\_STRICT, DELETE and DELETE\_STRICT commands can also be filtered by cookie value, if the \verb|cookie_mask| field contains a value other than 0. This constraint is that the bits specified by the \verb|cookie_mask| in both the \verb|cookie| field of the flow mod and a flow's \verb|cookie| value must be equal. In other words, (flow.cookie \& flow\_mod.cookie\_mask) == (flow\_mod.cookie \& flow\_mod.cookie\_mask).

\subsection{Flow Removal}

Each flow entry has an \verb|idle_timeout| and a \verb|hard_timeout| associated with it.  If no packet has matched the rule in the last \verb|idle_timeout| seconds, or it has been \verb|hard_timeout| seconds since the flow was inserted, the switch removes the entry and sends a flow removed message.  In addition, the controller is able to actively remove entries by sending a flow message with the \verb|DELETE| or \verb|DELETE_STRICT| command.  Like the message used to add the entry, a removal message contains a description, which may include wild cards.

\subsection{Group Table Modification Messages}
\label{group_table:sec_chan:group_mod}
\label{group_table:sec_chan:group_add}
\label{group_table:sec_chan:group_set}
\label{group_table:sec_chan:group_delete}
Group table modification messages can have the following types:
\input{enum/ofp_group_mod_command}

The action set for each bucket must be validated using the same rules as those for flow mods (Section \ref{flow_table:sec_chan:flow_add}), with additional group-specific checks.  Groups may consist of zero or more buckets. A group with no buckets will not alter the action set associated with a packet. A group may also include buckets which themselves forward to other groups. For example, a fast reroute group may have two buckets, where each points to a multipath group. If a switch does not support groups of groups, it must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_CHAINING_UNSUPPORTED| code.  If a group mod is sent such that a forwarding loop would be created, the switch should send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_LOOP| code.  If the switch does not support such checking, the forwarding behavior is undefined.
\\\\
For ADD requests, if a group entry with the specified group identifier already resides in the group table, then the switch must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_GROUP_EXISTS| code.
\\\\
For MODIFY requests, if a group entry with the specified group identifier already resides in the group table, then that entry, including its type and action buckets, must be removed, and the new group entry added.
\\\\
If a specified group type is invalid (ie: includes fields such as \verb|weight| that are undefined for the specified group type) then the switch must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_INVALID_GROUP| code.
\\\\
If a switch does not support unequal load sharing with multipath groups (buckets with weight different than 1), it must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_WEIGHT_UNSUPPORTED| code.
\\\\
If a switch cannot add the incoming group entry due to lack of space, the switch must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_OUT_OF_GROUPS| code.
\\\\
If a switch cannot add the incoming group entry due to restrictions (hardware or otherwise) limiting the number of group buckets, it must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_OUT_OF_BUCKETS| code.
\\\\
If a switch cannot add the incoming group because it does not support the proposed liveleness configuration, the switch must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_WATCH_UNSUPPORTED| code. This includes specifying \verb|watch_port| or \verb|watch_group| for a group that does not support liveness, or specifying a port that does not support liveness in \verb|watch_port|, or specifying a group that does not support liveness in \verb|watch_group|.
\\\\
For DELETE requests, if no group entry with the specified group identifier currently exists in the group table, no error is recorded, and no group table modification occurs.  Otherwise, the group is removed, and all flows that forward to the group are also removed. The group type need not be specified for the DELETE request. DELETE also differs from an ADD or MODIFY with no buckets specified in that future attempts to ADD the group identifier will not result in a group exists error.  If one wishes to effectively delete a group yet leave in flow entries using it, that group can be cleared by sending a MODIFY with no buckets specified.
\\\\
To delete all groups with a single message, specify \verb|OFPG_ALL| as the group value.
\\\\
Fast failover group support requires liveness monitoring, to determine the specific bucket to execute. Other group types are not required to implement liveness monitoring, but may optionally implement it.  If a switch cannot implement liveness checking for any bucket in a group, it must refuse the group mod and return an error.  The rules for determining liveness include:
\begin{itemize}
\item A port is considered live if it has the \verb|OFPPS_LIVE| flag set in its port state.  Port liveness may be managed by code outside of the OpenFlow portion of a switch, defined outside of the OpenFlow spec (such as Spanning Tree or a KeepAlive mechanism).  At a minimum, the port should not be considered live if the port config bit \verb|OFPPC_PORT_DOWN| indicates the port is down, or if the port state bit \verb|OFPPS_LINK_DOWN| indicates the link is down.
\item A bucket is considered live if either the port or the group watched by the bucket are live.
\item A group is considered live if a least one of its buckets is live.
\end{itemize}

The controller can infer the liveness state of the group by monitoring the states of the various ports.

\input{appendix}

\input{credits}
 
\end{document} 
