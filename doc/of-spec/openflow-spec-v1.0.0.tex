\documentclass[10pt]{article} 
\usepackage{amsmath}
\usepackage{listings}
\usepackage{hyperref}
\usepackage{fancyhdr}
\usepackage{graphicx}
\usepackage{tabularx}
\usepackage{color}
\usepackage{alltt}
\usepackage{rotating}
\usepackage{xtab}
\usepackage{calc}
\usepackage{appendix}
\usepackage{subfigure}

\hbadness=10000 % No "underfull hbox" messages

\begin{document}

%\lstset{language=C}

% Define the OpenFlow version here
\newcommand{\ofversion}{1.1.0}

% Calculations of widths for multipage tables
%
% Action table
\newlength{\atactionwidth}
\newlength{\atassocwidth}
\newlength{\atdescwidth}
\setlength{\atactionwidth}{0.25\textwidth - 2 \tabcolsep}
\setlength{\atassocwidth}{0.30\textwidth - 2 \tabcolsep}
\setlength{\atdescwidth}{0.45\textwidth - 2 \tabcolsep}

\pagestyle{fancy}
\fancyhead{}
\lhead{OpenFlow Switch Specification}
\rhead{Version \ofversion}
\renewcommand{\headrulewidth}{0.4pt}
\renewcommand{\footrulewidth}{0.4pt}

\fontfamily{cmr} % what about cmss?
\selectfont

\title{OpenFlow Switch Specification}
\author{Version \ofversion{} ( Wire Protocol \input{define/OFP_VERSION})}
\date{\today}
\maketitle

\tableofcontents
\listoftables
\listoffigures
\clearpage

\section{Introduction}
This document describes the requirements of an OpenFlow Switch.  We recommend that you read the latest version of the OpenFlow whitepaper before reading this specification. The whitepaper is available on the  OpenFlow Consortium website (\url{http://openflow.org}). This specification covers the components and the basic functions of the switch, and the OpenFlow protocol to manage an OpenFlow switch from a remote controller.
\\\\

\begin{figure}[htbp]
\centering
\includegraphics[height=2.8in]{switch_overview}
\caption{An OpenFlow switch communicates with a controller over a secure connection using the OpenFlow protocol.}
\label{fig:flow table and controller}
\end{figure}

\section{Switch Components}
An OpenFlow Switch consists of one or more \emph{flow tables} and a \emph{group table}, which perform packet lookups and forwarding, and a \emph{secure channel} to an external controller (Figure \ref{fig:flow table and controller}).  The controller manages the switch via the OpenFlow protocol.   Using this protocol, the controller can add, update, and delete \emph{flow entries}, both reactively (in response to packets) and proactively.
\\\\
Each flow table in the switch contains a set of flow entries; each flow entry consists of \emph{match fields}, \emph{counters}, and a set of \emph{instructions} to apply to matching packets (see \ref{ft:flowtableentry}).
\\\\
Matching starts at the first flow table (number 0) and may continue to additional flow tables (see \ref{sec:pipeline}). Flow entries match packets in priority order, with the first matching entry in each table being used (see \ref{sec:matching}). If a matching entry is found, the instructions associated with the specific flow entry are executed. If no match is found in a flow table, the outcome depends on switch configuration: the packet may be forwarded to the controller over the secure channel, dropped, or may continue to the next flow table (see \ref{sec:pipeline}).
\\\\
Instructions associated with each flow entry describe packet forwarding, packet modification, group table processing, and pipeline processing (see \ref{ft:instructions}). Pipeline processing instructions allow packets to be sent to subsequent tables for further processing and allow information, in the form of metadata, to be communicated between tables. Table pipeline processing stops when the instruction set associated with a matching flow entry does not specify a next table; at this point the packet is usually modified and forwarded (see \ref{ft:actionset}).
\\\\
Flow entries may forward to a \emph{port}. This is usually a physical port, but it may also be a virtual port reserved by the switch or by this specification. Virtual ports may specify generic forwarding actions such as sending to the controller, flooding, or forwarding using non-OpenFlow methods, such as ``normal'' switch processing (see \ref{ft:actions}) or tunnel interfaces (see \ref{ft:actions}).
\\\\
Flow entries may also point to a group, which specifies additional processing (see \ref{sec:group table}). Groups represent sets of actions for flooding, as well as more complex forwarding semantics (e.g. multipath, fast reroute, and link aggregation).  As a general layer of indirection, groups also enable multiple flows to forward to a single identifier (e.g. IP forwarding to a common next hop).  This abstraction allows common output actions across flows to be changed efficiently.
\\\\
The group table contains group entries; each group entry contains a list of \emph{action buckets} with specific semantics dependent on group type (see \ref{sec:group types}). The actions in one or more action buckets are applied to packets sent to the group.
\\\\
Switch designers are free to implement the internals in any way convenient, provided that correct match and instruction semantics are preserved. For example, while a flow may use a flood group to forward to multiple ports, a switch designer may choose to implement this as a single bitmask within the hardware forwarding table.  Another example is matching; the pipeline exposed by an OpenFlow switch may be physically implemented with a different number of hardware tables.

\section{Glossary}
This section describes key OpenFlow specification terms:
\begin{itemize}
\item \textbf{Byte}: an 8-bit octet.
\item \textbf{Port}: is a physical or virtual port. Virtual ports include reserved ports defined by this specification as well as higher level abstractions that may be defined in the switch using non-OpenFlow methods (e.g. link aggregation groups, tunnels, loopback interfaces).
\item \textbf{Match Field}: a field against which a packet is matched, including packet headers, the ingress port, and the metadata value.
\item \textbf{Metadata}: a maskable register value that is used to carry information from one table to the next.
\item \textbf{Instruction}: an operation that either contains a set of actions to add to the action set, contains a set of actions to apply immediately to the packet, or modifies pipeline processing.
\item \textbf{Action}: an operation that forwards the packet to a port or modifies the packet, such as decrementing the TTL field. Actions may be specified as part of the instruction set associated with a flow entry or in an action bucket associated with a group entry.
\item \textbf{Action Set}: a set of actions associated with the packet that are accumulated while the packet is processed by each table and that are executed when the instruction set instructs the packet to exit the processing pipeline.
\item \textbf{Group}: a list of action buckets and some means of choosing one or more of those buckets to apply on a per-packet basis.
\item \textbf{Action Bucket}: a set of actions and associated parameters, defined for groups.
\item \textbf{Tag}: a header that can be inserted or removed from a packet via push and pop actions.
\item \textbf{Outermost Tag}: the tag that appears closest to the beginning of a packet.
\end{itemize}

\section{OpenFlow Tables}
This section describes the components of flow tables and group tables, along with the mechanics of matching and action handling.

\subsection{Flow Table}
\label{ft:flowtableentry}

A flow table consists of flow entries.

\begin{table}[hbp]
\centering
\begin{tabular}{|c|c|c|}
\hline	
Match Fields & Counters & Instructions\\ 
\hline	
\end{tabular}
\caption{A flow entry consists of match fields, counters, and instructions.}
\label{table:flow entry}
\end{table}

Each flow table entry (see Table \ref{table:flow entry}) contains: 
\begin{itemize} 
\item \textbf{match fields}: to match against packets. These consist of the ingress port and packet headers, and optionally metadata specified by a previous table.
\item \textbf{counters}: to update for matching packets
\item \textbf{instructions} to modify the action set or pipeline processing
\end{itemize} 

\subsubsection{Pipeline Processing}
\label{sec:pipeline}

\begin{figure}[htbp]
\centering
\subfigure[Packets are matched against multiple tables in the pipeline]{
\includegraphics[width=\textwidth]{pipeline_flow_overview}
}
\subfigure[Per-table packet processing]{
\includegraphics[width=\textwidth]{pipeline_flow_detail}
}
\caption{Packet flow through the processing pipeline}
\label{fig:packet flow multiple tables}
\end{figure}

OpenFlow-compliant switches come in two types: \emph{OpenFlow-only}, and \emph{OpenFlow-hybrid}. \textbf{OpenFlow-only} switches support only OpenFlow operation, in those switches all packets are processed by the OpenFlow pipeline, and can not be processed otherwise.
\\\\
\textbf{OpenFlow-hybrid} switches support both OpenFlow operation and \emph{normal} Ethernet switching operation, i.e. traditional L2 Ethernet switching, VLAN isolation, L3 routing, ACL and QoS processing. Those switches should provide a classification mechanism outside of OpenFlow that routes traffic to \emph{either} the OpenFlow pipeline or the normal pipeline. For example, a switch may use the VLAN tag or input port of the packet to decide whether to process the packet using one pipeline or the other, or it may direct all packets to the OpenFlow pipeline. This classification mechanism is outside the scope of this specification. An OpenFlow-hybrid switches may also allow a packet to go from the OpenFlow pipeline to the normal pipeline through the \emph{NORMAL} virtual port (see \ref{ft:actions}).
\\\\
The \textbf{OpenFlow pipeline} of every OpenFlow switch contains multiple flow tables, each flow table containing multiple flow entries. The OpenFlow pipeline processing defines how packets interact with those flow tables (see Figure \ref{fig:packet flow multiple tables}). An OpenFlow switch with only a single flow table is valid, in this case pipeline processing is greatly simplified.
\\\\
The flow tables of an OpenFlow switch are sequentially numbered, starting at 0. Pipeline processing always starts at the first flow table: the packet is first matched against entries of flow table 0. Other flow tables may be used depending on the outcome of the match in the first table.
\\\\
If the packet matches a flow entry in a flow table, the corresponding set of instruction is executed (see \ref{sec:matching}). The instructions in the flow entry may explicitly direct the packet to another flow table (using the Goto Instruction, see \ref{ft:instructions}), where the same process is repeated again. A flow entry can only direct a packet to a flow table number which is greater than its own flow table number, in other words pipeline processing can only go forward and not backward. Obviously, the flow entries of the last table of the pipeline can not include the Goto instruction. If the matching flow entry does not direct packets to another flow table, pipeline processing stops at this table. When pipeline processing stops, the packet is processed with its associated action set and usually forwarded (see \ref{ft:actionset}).
\\\\
If the packet does not match a flow entry in a flow table, this is a table miss. The behavior on table miss depends on the table configuration; the default is to send packets to the controller over the control channel via a packet-in message (see \ref{sec:asynchronous}), another options is to drop the packet. A table can also specify that on a table miss the packet processing should continue; in this case the packet is processed by the next sequentially numbered table.

\subsection{Group Table}
\label{sec:group table}
A group table consists of group entries.  The ability for a flow to point to a \emph{group} enables OpenFlow to represent additional methods of forwarding (e.g. multipath and flood).
\\\\
\begin{table}[hbp]
\centering
\begin{tabular}{|c|c|c|}
\hline
Group Identifier & Group Type & Action Buckets\\
\hline
\end{tabular}
\caption{A group entry consists of a group identifier, a group type, and a list of action buckets.}
\label{table:group entry}
\end{table}
Each group entry (see Table \ref{table:group entry}) contains:
\begin{itemize}
\item \textbf{group identifier}: a 32 bit unsigned integer uniquely identifying the group
\item \textbf{group type}: to determine group semantics (see Section~\ref{sec:group types})
\item \textbf{action buckets}: an ordered list of action buckets, where each action bucket contains a set of actions to execute and associated parameters
\end{itemize}

\subsubsection{Group Types}
\label{sec:group types}
The following group types are defined:

\begin{itemize}
\item \textbf{flood}: Execute all buckets in the group.  Packets directed out the ingress port are dropped by default.  If the controller writer wants to forward out the ingress port, the bucket(s) should include a forward action to the \verb|OFPP_IN_PORT| in each bucket where this is desired.  This group is used for multicast or broadcast forwarding.
\item \textbf{multipath}: Execute one bucket in the group.  Packets are sent to a single bucket in the group, based on a switch-computed selection algorithm (e.g. hash on some user-configured tuple or simple round robin).  All configuration and state for the selection algorithm is external to OpenFlow.  When a port specified in a bucket in a multipath group goes down, the switch may restrict bucket selection to the remaining set (those with forwarding actions to live ports). This behavior may reduce the disruption of a downed link or switch.
\item \textbf{indirect}: Execute the one defined bucket in this group.  Allows multiple flows or groups to point to a common group identifier, supporting faster, more efficient convergence (e.g. next hops for IP forwarding).  This group type is effectively identical to flood groups with one bucket.
\item \textbf{fast failover}: Execute the first live bucket.  Each action bucket is associated with a specific port and/or group that controls its liveness.  Enables the switch to change forwarding without requiring a round trip to the controller.  If no buckets are live, packets are dropped. This group type must implement a \textit{liveness mechanism}(see \ref{group_table:sec_chan:group_mod}).
\end{itemize}

\subsection{Match Fields}
\begin{table}[hbp]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{ |X|X|X|X|X|X|X|X|X|X|X|X|X|XX|XX| }
\hline
\begin{sideways}Ingress Port \end{sideways} &
\begin{sideways}Metadata \end{sideways} &
\begin{sideways}Ether src \end{sideways} &
\begin{sideways}Ether dst \end{sideways} &
\begin{sideways}Ether type \end{sideways} &
\begin{sideways}VLAN id \end{sideways} &
\begin{sideways}VLAN priority \end{sideways} &
\begin{sideways}MPLS label \end{sideways} &
\begin{sideways}MPLS traffic class \end{sideways} &
\begin{sideways}IP src \end{sideways} &
\begin{sideways}IP dst \end{sideways} &
\begin{sideways}IP proto / ARP opcode \end{sideways} &
\begin{sideways}IP ToS bits \end{sideways} &
\begin{sideways}TCP/ UDP / SCTP src port \end{sideways} &
\begin{sideways}ICMP Type \end{sideways} &
\begin{sideways}TCP/ UDP / SCTP dst port \end{sideways} &
\begin{sideways}ICMP Code \end{sideways}
\\ 
\hline
\end{tabularx}
\caption{Fields from packets used to match against flow entries.}
\label{table:match fields}
\end{table}

Table \ref{table:match fields} shows the match fields an incoming packet is compared against. Each entry contains a specific value, or ANY, which matches any value. If the switch supports arbitrary bitmasks on the Ethernet source and/or destinations fields, or on the IP source and/or destination fields, these masks can more precisely specify matches.  The fields in the OpenFlow tuple are listed in Table \ref{table:match fields} and details on the properties of each field are described in Table \ref{table:header field details}. In addition to packet headers, matches can also be performed against the ingress port and metadata fields. Metadata may be used to pass information between tables in a switch.
\\\\
\begin{table}[hbp]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{ |X|X|X|X| }
\hline Field & Bits & When applicable & Notes \\
\hline Ingress Port & 32 & All packets & Numerical representation of incoming port, starting at 1. This may be a physical or virtual port as defined by the switch implementation. \\
\hline Metadata & 64 & Table 1 and above & \\
\hline Ethernet source address & 48 & All packets on enabled ports & Can use arbitrary bitmask \\
\hline Ethernet destination address & 48 & All packets on enabled ports & Can use arbitrary bitmask \\
\hline Ethernet type & 16 & All packets on enabled ports & An OpenFlow switch is required to match the type in both standard Ethernet and 802.2 with a SNAP header and OUI of 0x000000.  The special value of 0x05FF is used to match all 802.3 packets without SNAP headers. \\
\hline VLAN id & 12 & All packets with VLAN tags & VLAN identifier of \emph{outermost} VLAN tag. \\
\hline VLAN priority & 3 & All packets with VLAN tags & VLAN PCP field of \emph{outermost} VLAN tag. \\
\hline MPLS label & 20 & All packets with MPLS tags & Match on \emph{outermost} MPLS tag. \\
\hline MPLS traffic class & 3 & All packets with MPLS tags & Match on \emph{outermost} MPLS tag. \\
\hline IP source address & 32 & All IP and ARP packets & Can use subnet mask or arbitrary bitmask \\
\hline IP destination address & 32 & All IP and ARP packets & Can use subnet mask or arbitrary bitmask \\
\hline IP protocol / ARP opcode & 8 & All IP and IP over Ethernet, ARP packets & Only the lower 8 bits of the ARP opcode are used \\
\hline IP ToS bits & 6 & All IP packets & Specify as 8-bit value and place ToS in upper 6 bits. \\
\hline Transport source port / ICMP Type & 16 & All TCP, UDP, SCTP, and ICMP packets & Only lower 8 bits used for ICMP Type \\
\hline Transport destination port / ICMP Code & 16 & All TCP, UDP, SCTP, and ICMP packets & Only lower 8 bits used for ICMP Code \\
\hline
\end{tabularx}
\caption{Field lengths and the way they must be applied to flow entries.}
\label{table:header field details}
\end{table}

\subsection{Matching}
\label{sec:matching}
\begin{figure}[!htb]
\centering
\includegraphics[height=2.0in]{packet_flow_flowchart}
\caption{Flowchart detailing packet flow through an OpenFlow switch.}
\label{fig:packet_flow}
\end{figure}

\begin{figure}[!htb]
\centering
\includegraphics[width=\textwidth]{header_parsing_flowchart}
\caption{Flowchart showing how match fields are parsed for matching.}
\label{fig:header_parsing}
\end{figure}

On receipt of a packet, an OpenFlow Switch performs the functions shown in Figure \ref{fig:packet_flow}. The switch starts by performing a table lookup in the first flow table, and, based on pipeline processing, may perform table lookup in other flow tables (see \ref{sec:pipeline}). Match fields used for table lookups depend on the packet type as in Figure \ref{fig:header_parsing}.
\\\\
A packet matches a flow table entry if the values in the match fields used for the lookup (as defined in Figure~\ref{fig:header_parsing}) match those defined in the flow table.  If a flow table field has a value of ANY, it matches all possible values in the header.  
\\\\
To handle the various Ethernet framing types, matching the Ethernet type is handled in a slightly different manner.  If the packet is an Ethernet II frame, the Ethernet type is handled in the expected way.  If the packet is an 802.3 frame with a SNAP header and Organizationally Unique Identifier (OUI) of 0x000000, the SNAP protocol id is matched against the flow’s Ethernet type.  A flow entry that specifies an Ethernet type of 0x05FF, matches all Ethernet 802.2 frames without a SNAP header and those with SNAP headers that do not have an OUI of 0x000000.  
\\\\
The switch should apply the instruction set and update the associated counters of \emph{only} the highest-priority flow entry matching the packet.  If there are multiple matching flow entries with the same highest priority, the matching flow entry is explicitly undefined.  This case can only arise when a controller writer never sets the \verb|CHECK_OVERLAP| bit on flow mod messages and adds overlapping entries.


\subsection{Counters}

Counters may be maintained for each table, flow, port, queue, group, and bucket.  OpenFlow-compliant counters may be implemented in software and maintained by polling hardware counters with more limited ranges.
\\\\
Table \ref{table:counters} contains the set of counters.  Duration refers to the amount of time the flow has been installed in the switch.  The Receive Errors field is the total of all receive and collision errors defined in Table \ref{table:counters}, as well as any others not called out in the table.  Counters wrap around with no overflow indicator.
\begin{table}[!hbp]
\centering
\footnotesize
%\begin{tabularx}{\textwidth}{ |X|X| }
\begin{tabular}{ |l|c| }
\hline Counter & Bits	 \\
\hline \multicolumn{2}{|c|}{Per Table} \\
\hline Reference count (active entries) & 32 \\
\hline Packet Lookups & 64 \\
\hline Packet Matches & 64 \\
\hline \multicolumn{2}{|c|}{Per Flow} \\
\hline Received Packets & 64 \\
\hline Received Bytes & 64 \\
\hline Duration (seconds) & 32 \\
\hline Duration (nanoseconds) & 32 \\
\hline  \multicolumn{2}{|c|}{Per Port} \\
\hline Received Packets & 64 \\
\hline Transmitted Packets & 64 \\
\hline Received Bytes & 64 \\
\hline Transmitted Bytes & 64 \\
\hline Receive Drops & 64 \\
\hline Transmit Drops & 64 \\
\hline Receive Errors & 64 \\
\hline Transmit Errors & 64 \\
\hline Receive Frame Alignment Errors & 64 \\
\hline Receive Overrun Errors & 64 \\
\hline Receive CRC Errors & 64 \\
\hline Collisions & 64 \\
\hline  \multicolumn{2}{|c|}{Per Queue} \\
\hline Transmit Packets & 64 \\
\hline Transmit Bytes & 64 \\
\hline Transmit Overrun Errors & 64\\
\hline \multicolumn{2}{|c|}{Per Group} \\
\hline Reference Count (flow entries) & 32 \\
\hline Packet Count & 64 \\
\hline Byte Count & 64 \\
\hline \multicolumn{2}{|c|}{Per Bucket} \\
\hline Packet Count & 64 \\
\hline Byte Count & 64 \\
\hline
\end{tabular}
\caption{List of counters}
\label{table:counters}
\end{table}

\subsection{Instructions}
\label{ft:instructions}
Each flow entry contains a set of instructions that are executed when a packet matches the entry. These instructions result in changes to the packet, action set and/or pipeline processing (see: \ref{ft:actionset}). Supported instructions include:
\begin{itemize} 
\item \textbf{Clear-Actions}: Clears all the actions in the action set immediately.
\item \textbf{Apply-Actions \textit{action(s)}}: Applies the specific action(s) immediately, without any change to the Action Set. This instruction may be used to modify the packet between two tables or to execute multiple actions of the same type.
\item \textbf{Write-Actions \textit{action(s)}}: Merges the specified action(s) into the current action set.  If an action of the given type exists in the current set, overwrite it, otherwise add it.
\item \textbf{Write-Metadata \textit{metadata / mask}}: Writes the masked metadata value into the metadata field. The mask specifies which bits of the metadata register should be modified (i.e. new\_metadata = old\_metadata \& \~{}mask $|$ value \& mask).
\item \textbf{Goto-Table \textit{next-table-id}}: Indicates the next table in the processing pipeline. The table-id must be greater than the current table-id. The flows of last table of the pipeline can not include this instruction (see \ref{sec:pipeline}).
\end{itemize} 

A switch may reject a flow entry if it is unable to execute the instructions associated with the flow entry. In this case, the switch must return an unsupported flow error.  Flow tables may not support every match and every instruction.

\subsection{Action Set}
\label{ft:actionset}
An action set is associated with each packet. This set is empty by default. A flow entry can modify the action set using instructions associated with a particular match. The action set is carried between flow tables. When an instruction set does not contain a \textit{Goto-Table} instruction, pipeline processing stops and the actions in the action set are executed. If the action set does not contain an output action, the packet will be dropped. The output action in the action set is executed last.
\\\\
An action set contains a maximum of one action of each type, and may not simultaneously contain both Forward and Group actions. When multiple actions of the same type are required, e.g. pushing multiple MPLS labels or popping multiple MPLS labels, the \emph{Apply-Actions} instruction may be used.

\subsection{Actions}
\label{ft:actions}
A switch is not required to support all action types --- just those marked ``Required Actions'' below. When connecting to the controller, a switch indicates which of the ``Optional Actions'' it supports.
\\\\
\textbf{Required Action:} \textit{Output}.
The Output action forwards a packet to a specified port. OpenFlow switches must support forwarding to physical ports and the following virtual ones:
\begin{itemize}
\item \textbf{ALL:} Send the packet out all physical ports and the \verb|LOCAL| port, but not to the ingress port or ports that are configured \verb|OFPPC_NO_FWD|.
\item \textbf{CONTROLLER:} Encapsulate and send the packet to the controller.
\item \textbf{TABLE:} Submit the packet to the first flow table so that the packet can be processed through the regular OpenFlow pipeline.  Only valid in the action set of a packet-out message.
\item \textbf{IN\_PORT:} Send the packet out the ingress port. 
\end{itemize}
\textbf{Optional Action:} \textit{Output}.
The switch may optionally support forwarding to the following virtual ports:
\begin{itemize}
\item \textbf{LOCAL:} Send the packet to the switch's local networking stack. The local port enables remote entities to interact with the switch via the OpenFlow network, rather than via a separate control network. With a suitable set of default rules it can be used to implement an in-band controller connection.
\item \textbf{NORMAL:} Process the packet using the traditional non-OpenFlow pipeline of the switch (see \ref{sec:pipeline}). If the switch cannot forward packets from the OpenFlow pipeline to the normal pipeline, it must indicate that it does not support this action.
\item \textbf{FLOOD:} Send the packet out all physical ports and the \verb|LOCAL| port, but not to the ingress port, ports that are configured \verb|OFPPC_NO_FWD|, or ports that are in \verb|OFPPS_BLOCKED| state. The switch may optionally restrict forwarding to the VLAN matching the packet VLAN header field.

\end{itemize}

\emph{OpenFlow-only} switches do not support output actions to the \textbf{NORMAL} port, while \emph{OpenFlow-hybrid} may support it. Either type of switch may support output actions to the \textbf{FLOOD} port.
\\\\
\textbf{Optional Action:} \emph{Set-Queue}. The set-queue action sets the queue id for a packet. When the packet is forwarded to a port using the output action, the queue id determine which queue attached to this port is used for forwarding the packet. Forwarding behavior is dictated by the configuration of the queue and is used to provide basic Quality-of-Service (QoS) support (see section \ref{cts:qos}).
\\\\
\textbf{Required Action:} \emph{Drop}.  There is no explicit action to represent drops.  Instead, packets whose action sets have no output actions should be dropped.  This result could come from empty instruction sets or empty action buckets in the processing pipeline, or after executing a Clear-Actions instruction.
\\\\
\textbf{Optional Action:} \emph{Push-Tag/Pop-Tag}.  Switches may support the ability to push/pop tags as shown in Table \ref{table:push pop actions}.  To aid integration with existing networks, we suggest that the ability to push/pop VLAN tags be supported.

The ordering of header fields/tags is:
\begin{center}
\begin{tabular}{|l|l|l|l|l|}
\hline
Ethernet & VLAN & MPLS & ARP/IP & TCP/UDP/SCTP (IP-only) \\
\hline
\end{tabular}
\end{center}
Newly pushed tags should \emph{always} be inserted as the outermost tag in this ordering. When a new VLAN tag is pushed, it should be the outermost VLAN tag inserted immediately after the Ethernet header. Likewise, when a new MPLS tag is pushed, it should be the outermost MPLS tag, inserted as a shim header after any VLAN tags.
\\\\
Note: Refer to section~\ref{sec:push field defaults} for information on default field values.
\\\\
\textbf{Optional Action:} \emph{Set-Field}.  The various Set-Field actions modify the values of the respective header field in the packet. While not strictly required, the actions shown in Table \ref{table:set-field actions}  greatly increase the usefulness of an OpenFlow implementation.  To aid integration with existing networks, we suggest that VLAN modification actions be supported. Set-Field actions should \emph{always} be applied to the outermost-possible header (e.g.~a ``Set VLAN ID'' action always sets the ID of the outermost VLAN tag).
\\\\
\textbf{Required Action:} \emph{Group}.  Process the packet through the specified group.  The exact interpretation depends on group type. 

\begin{table}[hbp]
\centering
\footnotesize
\begin{tabularx}{\textwidth}{ |l|c|X| }
\hline
Action & Associated Data & Description \\
\hline
Push VLAN header &
Ethertype &
Push a new VLAN header onto the packet.

The Ethertype is used as the Ethertype for the tag. Only Ethertype 0x8100 and 0x88a8 should be used.
\\
\hline
Pop VLAN header &
- &
Pop the outer-most VLAN header from the packet. \\
\hline
Push MPLS header &
Ethertype &
Push a new MPLS shim header onto the packet.

The Ethertype is used as the Ethertype for the header only if the new tag being pushed is the bottom of stack. Only Ethertype 0x8847 and 0x8848 should be used.
\\
\hline
Pop MPLS header &
Ethertype &
Pop the outer-most MPLS tag or shim header from the packet.

The Ethertype is only used when popping the bottom of stack and indicates the Ethertype of the payload.
\\
\hline
\end{tabularx}
\caption{Push/pop tag actions.}
\label{table:push pop actions}
\end{table}

\bottomcaption{Set-Field actions.}
\label{table:set-field actions}
\tablefirsthead{\hline \textbf{Action} & \textbf{Associated Data} &
                       \textbf{Description} \\
		       \hline }
\tablehead{\multicolumn{3}{c}%
           {{\bfseries \tablename\ \thetable{} -- continued from previous page}} \\
           \hline \textbf{Action} & \textbf{Associated Data} &
                  \textbf{Description} \\
	          \hline }
\tablelasthead{\multicolumn{3}{c}%
           {{\bfseries \tablename\ \thetable{} -- concluded from previous page}} \\
           \hline \textbf{Action} & \textbf{Associated Data} &
                  \textbf{Description} \\
	          }
\tabletail{\hline \multicolumn{3}{|r|}{{Continued on next page}} \\ \hline}
\tablelasttail{\hline}
\xentrystretch{0}
\begin{xtabular}{ |p{\atactionwidth}|p{\atassocwidth}|p{\atdescwidth}| }
Set Ethernet source MAC address &
48 bits: New source MAC address &
Replace the existing Ethernet source MAC address. \\
\hline
Set Ethernet destination MAC address &
48 bits: New destination MAC address &
Replace the existing Ethernet destination MAC address. \\
\hline
Set VLAN ID &
12 bits: New VLAN ID &
Replace the existing VLAN ID.
Only applies to packets with an existing VLAN tag. \\
\hline
Set VLAN priority &
3 bits: New VLAN priority &
Replace the existing VLAN priority.
Only applies to packets with an existing VLAN tag. \\
\hline
Set MPLS label &
20 bits: New MPLS label &
Replace the existing MPLS label.
Only applies to packets with an existing MPLS shim header. \\
\hline
Set MPLS traffic class &
3 bits: New MPLS traffic class &
Replace the existing MPLS traffic class.
Only applies to packets with an existing MPLS shim header. \\
\hline
Set MPLS TTL &
8 bits: New MPLS TTL &
Replace the existing MPLS TTL.
Only applies to packets with an existing MPLS shim header. \\
\hline
Decrement MPLS TTL &
- &
Decrement the MPLS TTL.
Only applies to packets with an existing MPLS shim header. \\
\hline
Set IPv4 source address &
32 bits: New IPv4 source address &
Replace the existing IP source address with new value and update the IP checksum (and TCP/UDP/SCTP 
checksum if applicable). 

This action is only applicable to IPv4 packets. \\
\hline
Set IPv4 destination address &
32 bits: New IPv4 destination address &
Replace the existing IP destination address with and update the IP checksum (and TCP/UDP/SCTP checksum if applicable).

This action is only applied to IPv4 packets. \\
\hline
Set IPv4 ToS bits &
6 bits: New IPv4 ToS &
Replace the existing IP ToS and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Set IPv4 ECN bits &
2 bits: New IPv4 ECN &
Replace the existing IP ECN value and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Set IPv4 TTL &
8 bits: New IPv4 TTL &
Replace the existing IP TTL and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Decrement IPv4 TTL &
- &
Decrement the IP TTL field and update the IP checksum.
Only applies to IPv4 packets. \\
\hline
Set transport source port &
16 bits: New TCP, UDP or SCTP source port &
Replace the existing TCP/UDP/SCTP source port with new value and update the TCP/UDP/SCTP checksum.

This action is only applicable to TCP, UDP and SCTP packets.\\
\hline
Set transport destination port &
16 bits: New TCP, UDP or SCTP destination port &
Replace the existing TCP/UDP/SCTP destination port with new value and update the TCP/UDP/SCTP checksum

Only applies to TCP, UDP and SCTP packets.\\
\hline
Copy TTL outwards&
- &
Copy the TTL from next-to-outermost to outermost header with TTL.

Copy can be IP-to-IP, MPLS-to-MPLS, or IP-to-MPLS.
\\
\hline
Copy TTL inwards&
- &
Copy the TTL from outermost to next-to-outermost header with TTL.

Copy can be IP-to-IP, MPLS-to-MPLS, or MPLS-to-IP.
\\
\end{xtabular}

\subsubsection{Default values for fields on push}
\label{sec:push field defaults}
Field values should be copied from existing outer headers to new outer headers when executing a push action. New fields without corresponding existing fields should be set to \emph{zero}. Table~\ref{table:push field copy} details the existing fields from which a new field may take it's value.

\begin{table}[hbp]
\centering
\begin{tabular}{lcl}
\textbf{New Fields} & & \textbf{Existing Field(s)} \\
\hline
VLAN ID & $\leftarrow$ & VLAN ID \\
VLAN priority & $\leftarrow$ & VLAN priority \\
MPLS label & $\leftarrow$ & MPLS label \\
MPLS traffic class & $\leftarrow$ & MPLS traffic class \\
MPLS TTL & $\leftarrow$ &
$\left\{
\begin{array}{l}
  \mathrm{MPLS\ TTL} \\ \mathrm{IP\ TTL}
\end{array}
\right.$ \\
\end{tabular}
\caption{Existing fields that may be copied into new fields on a push action.}
\label{table:push field copy}
\end{table}

Fields in new headers may be overridden by specifying a ``set'' action for the appropriate field(s) after the push operation.

\section{Secure Channel}
The secure channel is the interface that connects each OpenFlow switch to a controller.  Through this interface, the controller configures and manages the switch, receives events from the switch, and sends packets out the switch.
\\\\
Between the datapath and the secure channel, the interface is implementation-specific, however all secure channel messages must be formatted according to the OpenFlow protocol. 
\\\\
Support for multiple simultaneous controllers is currently undefined.

\subsection{OpenFlow Protocol Overview}
The OpenFlow protocol supports three message types, \emph{controller-to-switch}, \emph{asynchronous}, and \emph{symmetric}, each with multiple sub-types.  Controller-to-switch messages are initiated by the controller and used to directly manage or inspect the state of the switch.  Asynchronous messages are initiated by the switch and used to update the controller of network events and changes to the switch state. Symmetric messages are initiated by either the switch or the controller and sent without solicitation.  The message types used by OpenFlow are described below.

\subsubsection{Controller-to-Switch}
Controller/switch messages are initiated by the controller and may or may not require a response from the switch.
\\\\
\textbf{Features:}  The controller may request the capabilities of a switch by sending a features request; the switch must respond with a features reply that specifies the capabilities of the switch. This is commonly performed upon Transport Layer Security (TLS) session establishment.
\\\\
\textbf{Configuration:} The controller is able to set and query configuration parameters in the switch.  The switch only responds to a query from the controller.
\\\\
\textbf{Modify-State:} Modify-State messages are sent by the controller to manage state on the switches.  Their primary purpose is to add/delete and modify flows/groups in the OpenFlow tables and to set switch port properties.
\\\\
\textbf{Read-State:} Read-State messages are used by the controller to collect statistics from the switch.
\\\\\
\textbf{Send-Packet}:  These are used by the controller to send packets out of a specified port on the switch.
\\\\
\textbf{Barrier}: Barrier request/reply messages are used by the controller to ensure message dependencies have been met or to receive notifications for completed operations.  

\subsubsection{Asynchronous}
\label{sec:asynchronous}
Asynchronous messages are sent without the controller soliciting them from a switch.  Switches send asynchronous messages to the controller to denote a packet arrival, switch state change, or error.  The four main asynchronous message types are described below.
\\\\
\textbf{Packet-in:} For all packets that do not have a matching flow entry, a packet-in event may be sent to the controller (depending on the table configuration). For all packets forwarded to the \textbf{CONTROLLER} virtual port, a packet-in event is always sent to the controller.  If the switch has sufficient memory to buffer packets that are sent to the controller, the packet-in events contain some fraction of the packet header (by default \input{define/OFP_DEFAULT_MISS_SEND_LEN} bytes) and a buffer ID to be used by the controller when it is ready for the switch to forward the packet.  Switches that do not support internal buffering (or have run out of internal buffering) must send the full packet to the controller as part of the event.
\\\\
\textbf{Flow-Removed:} When a flow entry is added to the switch by a flow modify message, an idle timeout value indicates when the entry should be removed due to a lack of activity, as well as a hard timeout value that indicates when the entry should be removed, regardless of activity.  The flow modify message also specifies whether the switch should send a flow removed message to the controller when the flow expires.  Flow modify messages which delete flows should generate flow removed messages for any flows with the \verb|OFPFF_SEND_FLOW_REM| flag set.
\\\\
\textbf{Port-status:} The switch is expected to send port-status messages to the controller as port configuration state changes.  These events include change in port status events (for example, if it was brought down directly by a user).
\\\\
\textbf{Error:} The switch is able to notify the controller of problems using error messages. 

\subsubsection{Symmetric}
Symmetric messages are sent without solicitation, in either direction.
\\\\
\textbf{Hello:} Hello messages are exchanged between the switch and controller upon connection startup.
\\\\
\textbf{Echo:} Echo request/reply messages can be sent from either the switch or the controller, and must return an echo reply.  They can be used to indicate the latency, bandwidth, and/or liveness of a controller-switch connection.
\\\\
\textbf{Experimenter:} Experimenter messages provide a standard way for OpenFlow switches to offer additional functionality within the OpenFlow message type space.  This is a staging area for features meant for future OpenFlow revisions.

\subsection{Connection Setup}
The switch must be able to establish communication with a controller at a user-configurable (but otherwise fixed) IP address, using a user-specified port.  Traffic to and from the secure channel is not checked against the flow table.  Therefore, the switch must identify incoming traffic as local before checking it against the flow table.  Future versions of the protocol specification will describe a dynamic controller discovery protocol in which the IP address and port for communicating with the controller is determined at runtime.
\\\\
When an OpenFlow connection is first established, each side of the connection must immediately send an \verb|OFPT_HELLO| message with the \verb|version| field set to the highest OpenFlow protocol version supported by the sender.  Upon receipt of this message, the recipient may calculate the OpenFlow protocol version to be used as the smaller of the version number that it sent and the one that it received.
\\\\
If the negotiated version is supported by the recipient, then the connection proceeds. Otherwise, the recipient must reply with an \verb|OFPT_ERROR| message with a \verb|type| field of \verb|OFPET_HELLO_FAILED|, a \verb|code| field of \verb| OFPHFC_COMPATIBLE|, and optionally an ASCII string explaining the situation in \verb|data|, and then terminate the connection.

\subsection{Connection Interruption}
In the case that a switch loses contact with the controller, as a result of a echo request timeout, TLS session timeout, or other disconnection, it should attempt to contact one or more backup controllers.  The ordering of the controller IP addresses is not specified by the protocol.
\\\\
If some number of attempts to contact a controller (zero or more) fail, the switch may either enter ``fail secure mode'' or ``fail standalone mode'', depending on the switch implementation and its configuration. In ``fail secure mode'', the switch continues to operate according to OpenFlow procedures, with the exception that packets and messages destined to the controller are dropped and no new flow table entries are set up by the controller. In ``fail standalone mode'', the switch process all packets using the \verb|OFPP_NORMAL| port; in other words, the switch acts as a legacy Ethernet switch or router. 
\\\\
Upon connecting to a controller again, the existing flow entries remain.  The controller then has the option of deleting all flow entries, if desired.
\\\\
The first time a switch starts up, it will operate in either ``fail secure mode'' or ``fail standalone mode'' mode.  Configuration of the default set of flow entries to be used at startup is outside the scope of the OpenFlow protocol.

\subsection{Encryption}
The switch and controller communicate through a TLS connection.  The TLS connection is initiated by the switch on startup to the controller, which is located by default on TCP port \input{define/OFP_TCP_PORT}.   The switch and controller mutually authenticate by exchanging certificates signed by a site-specific private key.  Each switch must be user-configurable with one certificate for authenticating the controller (controller certificate) and the other for authenticating to the controller (switch certificate).

\subsection{Flow Table Modification Messages}
\label{sec:flow mod messages}
\label{flow_table:sec_chan:flow_add}
\label{flow_table:sec_chan:flow_mod}
\label{flow_table:sec_chan:flow_removal}
Flow table modification messages can have the following types:
\input{enum/ofp_flow_mod_command}
For ADD requests with the \verb|OFPFF_CHECK_OVERLAP| flag set, the switch must first check for any overlapping flow entries.  Two flow entries overlap if a single packet may match both, and both entries have the same priority.  If an overlap conflict exists between an existing flow entry and the ADD request, the switch must refuse the addition and respond with an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMFC_OVERLAP| code.
\\\\
For valid (non-overlapping) ADD requests, or those with no overlap checking, the switch must insert the flow entry to the requested table.  If a flow entry with identical match fields and priority already resides in the requested table, then that entry, including its counters, must be removed, and the new flow entry added.
\\\\
If a switch cannot find any space in the requested table in which to add the incoming flow entry, the switch should send an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMFC_TABLE_FULL| code.
\\\\
If the incoming flow entry requests an invalid table, the switch should send an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMFC_BAD_TABLE_ID| code.
\\\\
If the match fields requested in a flow mod message are unsupported in the table, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMC_BAD_MATCH| code.
\\\\
If the instructions requested in a flow mod message are unsupported, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMC_BAD_INSTRUCTION| code.
\\\\
If the match in a flow mod specifies an arbitrary bitmask for either the datalink or network addresses which the switch cannot support, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and either \verb|OFPFMFC_BAD_DL_ADDR_MASK| or \verb|OFPFMFC_BAD_NW_ADDR_MASK|. (If the bitmasks specified in \emph{both} the datalink and network addresses are not supported then \verb|OFPFMFC_BAD_DL_ADDR_MASK| should be used.)
\\\\
In the match in a flow mod specifies values that can not be matched, for example a VLAN ID greater than 4095 and not one of the reserved value, or a ToS value with one of the two lower bit set, the switch may return an \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMFC_BAD_MATCH| code.
\\\\
If any action references a port that will never be valid on a switch, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and \verb|OFPBAC_BAD_OUT_PORT| code.  If the referenced port may be valid in the future, e.g. when a linecard is added to a chassis switch, or a port is dynamically added to a software switch, the switch may either silently drop packets sent to the referenced port, or immediately return an \verb|OFPBAC_BAD_OUT_PORT| error and refuse the flow mod.
\\\\
If an action in a flow mod message references a group that is not currently defined on the switch, or is a reserved group, such as \verb|OFPG_ALL|, the switch must return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and \verb|OFPBAC_BAD_OUT_GROUP| code.
\\\\
If an action in a flow mod message has a value that is invalid, for example a Set VLAN ID action with value greater than 4095, or a Push action with an invalid Ethertype, the switch should return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and \verb|OFPBAC_BAD_ARGUMENT| code.
\\\\
If an action in a flow mod message performs an operation which is inconsistent with the match, for example, a pop VLAN action with a match specifying no VLAN, or a set IPv4 address action with a match wildcarding the Ethertype, the switch must apply this action conditionally to only packets where it can be performed (in the above example, IPv4 packet would have their IPv4 address rewritten and non-IPv4 packets would be left unchanged). If the switch can not implement this behaviour, it must reject the flow and must immediately return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and \verb|OFPBAC_MATCH_INCONSISTENT| code.
\\\\
If any other errors occur during the processing of the flow mod message, the switch may return an  \verb|ofp_error_msg| with \verb|OFPET_FLOW_MOD_FAILED| type and \verb|OFPFMC_UNKNOWN| code.
\\\\
For MODIFY requests, if a flow entry with identical match fields does not current reside in any table, the MODIFY acts like an ADD, and the new flow entry must be inserted with zeroed counters.  Otherwise, the actions field is changed on the existing entry and its counters, and idle time fields are left unchanged.
\\\\
For DELETE requests, if no flow entry matches, no error is recorded, and no flow table modification occurs.  If flow entries match, and must be deleted, then each entry with the \verb|OFPFF_SEND_FLOW_REM| flag set should generate a flow removed message.
\\\\
MODIFY and DELETE flow mod commands have corresponding \_STRICT versions.   Without \_STRICT appended, the wildcards are active and all flows that match the description are modified or removed.  If \_STRICT is appended, all fields, including the wildcards and priority, are strictly matched against the entry, and only an identical flow is modified or removed.  For example, if a message to remove entries is sent that has all the wildcard flags set, the DELETE command would delete all flows from all tables, while the DELETE\_STRICT command would only delete a rule that applies to all packets at the specified priority.
\\\\
For non-strict MODIFY and DELETE commands that contain wildcards, a match will occur when a flow entry exactly matches or is more specific than the description in the flow\_mod command. For example, if a DELETE command says to delete all flows with a destination port of 80, then a flow entry that is all wildcards will not be deleted. However, a DELETE command that is all wildcards will delete an entry that matches all port 80 traffic.  This same interpretation of mixed wildcard and exact match fields also applies to individual and aggregate flows stats.  
\\\\
DELETE and DELETE\_STRICT commands can be optionally filtered by destination group or output port.  If the \verb|out_port| field contains a value other than \verb|OFPP_ANY|, it introduces a constraint when matching.  This constraint is that the rule must contain an output action directed at the specified group or port.  This field is ignored by ADD, MODIFY, and MODIFY\_STRICT messages.
\\\\
MODIFY, MODIFY\_STRICT, DELETE and DELETE\_STRICT commands can also be filtered by cookie value, if the \verb|cookie_mask| field contains a value other than 0. This constraint is that the bits specified by the \verb|cookie_mask| in both the \verb|cookie| field of the flow mod and a flow's \verb|cookie| value must be equal. In other words, (flow.cookie \& flow\_mod.cookie\_mask) == (flow\_mod.cookie \& flow\_mod.cookie\_mask).

\subsection{Flow Removal}

Each flow entry has an \verb|idle_timeout| and a \verb|hard_timeout| associated with it.  If no packet has matched the rule in the last \verb|idle_timeout| seconds, or it has been \verb|hard_timeout| seconds since the flow was inserted, the switch removes the entry and sends a flow removed message.  In addition, the controller is able to actively remove entries by sending a flow message with the \verb|DELETE| or \verb|DELETE_STRICT| command.  Like the message used to add the entry, a removal message contains a description, which may include wild cards.

\subsection{Group Table Modification Messages}
\label{group_table:sec_chan:group_mod}
\label{group_table:sec_chan:group_add}
\label{group_table:sec_chan:group_set}
\label{group_table:sec_chan:group_delete}
Group table modification messages can have the following types:
\input{enum/ofp_group_mod_command}

The action set for each bucket must be validated using the same rules as those for flow mods (Section \ref{flow_table:sec_chan:flow_add}), with additional group-specific checks. If an action in one of the buckets is invalid or unsupported, the switch should return an \verb|ofp_error_msg| with \verb|OFPET_BAD_ACTION| type and code corresponding to the error (see \ref{flow_table:sec_chan:flow_add}).
\\\\
Groups may consist of zero or more buckets. A group with no buckets will not alter the action set associated with a packet. A group may also include buckets which themselves forward to other groups. For example, a fast reroute group may have two buckets, where each points to a multipath group. If a switch does not support groups of groups, it must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_CHAINING_UNSUPPORTED| code.  If a group mod is sent such that a forwarding loop would be created, the switch should send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_LOOP| code.  If the switch does not support such checking, the forwarding behavior is undefined.
\\\\
For ADD requests, if a group entry with the specified group identifier already resides in the group table, then the switch must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_GROUP_EXISTS| code.
\\\\
For MODIFY requests, if a group entry with the specified group identifier already resides in the group table, then that entry, including its type and action buckets, must be removed, and the new group entry added. If a group entry with the specified group identifier does not already exist then the switch must refuse the group mod and send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_UNKNOWN_GROUP| code.
\\\\
If a specified group type is invalid (ie: includes fields such as \verb|weight| that are undefined for the specified group type) then the switch must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_INVALID_GROUP| code.
\\\\
If a switch does not support unequal load sharing with multipath groups (buckets with weight different than 1), it must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_WEIGHT_UNSUPPORTED| code.
\\\\
If a switch cannot add the incoming group entry due to lack of space, the switch must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_OUT_OF_GROUPS| code.
\\\\
If a switch cannot add the incoming group entry due to restrictions (hardware or otherwise) limiting the number of group buckets, it must refuse to add the group entry and must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_OUT_OF_BUCKETS| code.
\\\\
If a switch cannot add the incoming group because it does not support the proposed liveliness configuration, the switch must send an \verb|ofp_error_msg| with \verb|OFPET_GROUP_MOD_FAILED| type and \verb|OFPGMFC_WATCH_UNSUPPORTED| code. This includes specifying \verb|watch_port| or \verb|watch_group| for a group that does not support liveness, or specifying a port that does not support liveness in \verb|watch_port|, or specifying a group that does not support liveness in \verb|watch_group|.
\\\\
For DELETE requests, if no group entry with the specified group identifier currently exists in the group table, no error is recorded, and no group table modification occurs.  Otherwise, the group is removed, and all flows that forward to the group are also removed. The group type need not be specified for the DELETE request. DELETE also differs from an ADD or MODIFY with no buckets specified in that future attempts to ADD the group identifier will not result in a group exists error.  If one wishes to effectively delete a group yet leave in flow entries using it, that group can be cleared by sending a MODIFY with no buckets specified.
\\\\
To delete all groups with a single message, specify \verb|OFPG_ALL| as the group value.
\\\\
Fast failover group support requires liveness monitoring, to determine the specific bucket to execute. Other group types are not required to implement liveness monitoring, but may optionally implement it.  If a switch cannot implement liveness checking for any bucket in a group, it must refuse the group mod and return an error.  The rules for determining liveness include:
\begin{itemize}
\item A port is considered live if it has the \verb|OFPPS_LIVE| flag set in its port state.  Port liveness may be managed by code outside of the OpenFlow portion of a switch, defined outside of the OpenFlow spec (such as Spanning Tree or a KeepAlive mechanism).  At a minimum, the port should not be considered live if the port config bit \verb|OFPPC_PORT_DOWN| indicates the port is down, or if the port state bit \verb|OFPPS_LINK_DOWN| indicates the link is down.
\item A bucket is considered live if either the port or the group watched by the bucket are live.
\item A group is considered live if a least one of its buckets is live.
\end{itemize}

The controller can infer the liveness state of the group by monitoring the states of the various ports.

\appendixtitleon
\begin{appendices}
\input{appendix}

\input{credits}
\end{appendices}
 
\end{document} 
